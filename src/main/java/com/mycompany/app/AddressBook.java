package com.mycompany.app;

import jakarta.persistence.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

/**
 * A JPA entity representing an address book.
 * By default, JPA maps this class to a table named ADDRESSBOOK (or AddressBook,
 * depending on the provider/database). Each instance is one row in that table.
 */
@Entity
public class AddressBook {

    /**
     * Primary key. The value is generated by the database using its identity
     * mechanism (auto-increment). This strategy works well with SQLite.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Unidirectional one-to-many relationship to BuddyInfo.
     *
     * - @OneToMany: An AddressBook "has many" BuddyInfo rows.
     *
     * - @JoinColumn(name = "addressbook_id"):
     *   Store the foreign key on the BuddyInfo table (column "addressbook_id").
     *   This avoids creating a separate join table and keeps the schema simple:
     *   BUDDYINFO(addressbook_id -> ADDRESSBOOK.id).
     *
     * - cascade = CascadeType.ALL:
     *   Propagate persistence operations from AddressBook to its buddies.
     *   Examples:
     *     em.persist(addressBook)  -> persists all BuddyInfo in buddyList
     *     em.merge(addressBook)    -> merges changes for both book and buddies
     *
     * - orphanRemoval = true:
     *   If a BuddyInfo is removed from buddyList while the AddressBook is managed
     *   (inside an active EntityManager/transaction), JPA will also DELETE that
     *   BuddyInfo row from the database on commit. This keeps the DB in sync with
     *   the in-memory list.
     *
     * Default fetch for OneToMany is LAZY: buddies are loaded on-demand when the
     * collection is accessed while the EntityManager is still open.
     */
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "addressbook_id")          // foreign key lives in BUDDYINFO
    private List<BuddyInfo> buddyList = new ArrayList<>();

    /**
     * JPA requires a no-arg constructor (public or protected) so it can
     * instantiate the entity via reflection.
     */
    public AddressBook() {}

    /**
     * Adds a BuddyInfo to the address book (in-memory only; DB is updated when
     * this entity is persisted/merged and the transaction commits).
     *
     * Because this mapping is UNIdirectional (AddressBook -> BuddyInfo only),
     * there's no back-reference to keep in sync here.
     */
    public void addBuddy(BuddyInfo buddy) {
        if (buddy != null) buddyList.add(buddy);
    }

    /**
     * Removes the BuddyInfo at the given index.
     * Returns the removed BuddyInfo or null if the index is invalid.
     *
     * With orphanRemoval=true, removing from the collection will cause JPA
     * to DELETE the corresponding row on transaction commit (provided the
     * AddressBook entity is managed).
     */
    public BuddyInfo removeBuddy(int index) {
        if (index >= 0 && index < buddyList.size()) return buddyList.remove(index);
        return null;
    }

    public boolean removeBuddyById(Long buddyId) {
        return buddyList.removeIf(b -> Objects.equals(b.getId(), buddyId));
    }
    /**
     * Exposes a read-only view of the buddies to prevent callers from modifying
     * the internal list outside of your add/remove methods (which enforce the
     * JPA semantics like orphanRemoval and cascade).
     */
    public List<BuddyInfo> getBuddyList() {
        return Collections.unmodifiableList(buddyList);
    }

    /** Convenience: how many buddies are in this book (in-memory). */
    public int size() { return buddyList.size(); }

    /** Primary key getter (useful after persist() assigns an id). */
    public Long getId() { return id; }
}

